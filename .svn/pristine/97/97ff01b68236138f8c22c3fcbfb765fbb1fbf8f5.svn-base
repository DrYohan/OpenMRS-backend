const ItemGRNModel = require("../models/itemGRNModel");
const {
  deleteFile,
  getFilePath,
  fileExists,
  generateItemSerial,
} = require("../utils/helpers");
const pool = require("../config/database");

class ItemGRNController {
  // Create new Item GRN - SINGLE TABLE VERSION
  static async createItemGRN(req, res) {
    const connection = await pool.getConnection();

    try {
      await connection.beginTransaction();

      console.log("=== CREATE ITEM GRN REQUEST ===");
      console.log("Request body:", req.body);
      console.log("Files received:", req.files ? req.files.length : 0);

      // Create trimmed version of req.body
      const trimmedBody = {};
      Object.keys(req.body).forEach((key) => {
        trimmedBody[key.trim()] = req.body[key];
      });

      // Process asset allocations if exists
      let assetAllocations = [];
      if (trimmedBody.assetAllocations) {
        try {
          assetAllocations = JSON.parse(trimmedBody.assetAllocations);
          console.log("Asset allocations parsed:", assetAllocations.length);
        } catch (error) {
          console.error("Error parsing asset allocations:", error);
        }
      }

      // Check if GRN number already exists
      const existingGRNs = await ItemGRNModel.findByGrnNo(trimmedBody.grn_no);
      const isExistingGRN = existingGRNs && existingGRNs.length > 0;

      // Get quantity
      const quantity = parseInt(trimmedBody.qty) || 1;

      // Check if we need to process images
      const hasFiles = req.files && req.files.length > 0;
      let imageData = {
        Item1Pic: null,
        Item2Pic: null,
        Item3Pic: null,
        Item4Pic: null,
      };

      // Process up to 4 images - store file paths
      if (hasFiles) {
        console.log(`Processing ${req.files.length} images for file paths`);

        for (let i = 0; i < Math.min(req.files.length, 4); i++) {
          const file = req.files[i];
          const imageKey = `Item${i + 1}Pic`;

          try {
            console.log(`Processing image ${i + 1}: ${file.originalname}`);
            console.log(`File saved at: ${file.path}`);

            // Store file path directly
            const filePath = file.path;
            imageData[imageKey] = filePath;
            console.log(`✓ Stored ${imageKey} path: ${filePath}`);
          } catch (error) {
            console.error(`Error getting file path for image ${i + 1}:`, error);
          }
        }
      } else {
        console.log("No images to process");
      }

      // Determine if we're in replicate mode
      const isReplicate =
        trimmedBody.replicate === "true" ||
        trimmedBody.replicate === true ||
        (assetAllocations.length > 1 && parseInt(trimmedBody.qty) > 1);

      // Generate custom ItemSerial for all items in this GRN
      let customItemSerial = null;

      if (isReplicate && assetAllocations.length > 0) {
        // Generate base ItemSerial for the group (first item)
        customItemSerial = await generateItemSerial(
          trimmedBody.grn_date,
          trimmedBody.grn_no,
          true, // isReplicate
          0 // First item index
        );
        console.log(
          `Generated custom ItemSerial for replicate group: ${customItemSerial}`
        );
      }

      // Prepare items to insert
      const itemsToInsert = [];
      const insertedIds = [];

      if (isReplicate && assetAllocations.length > 0) {
        // Replicate mode: Create multiple records for each asset allocation
        console.log(
          `Creating ${assetAllocations.length} items in replicate mode`
        );

        for (let i = 0; i < assetAllocations.length; i++) {
          const asset = assetAllocations[i];

          // Generate unique ItemSerial for each replicate item
          let itemSerial;
          if (i === 0) {
            // First item uses the base ItemSerial
            itemSerial = customItemSerial;
          } else {
            // Subsequent items get unique suffixes
            itemSerial = await generateItemSerial(
              trimmedBody.grn_date,
              trimmedBody.grn_no,
              true, // isReplicate
              i // Replicate index
            );
          }

          const itemGRNData = {
            // UNIQUE ItemSerial for each item
            item_serial: itemSerial,

            // Main form fields
            middle_category: trimmedBody.middle_category || "",
            sub_category: trimmedBody.sub_category || "",
            item_name: trimmedBody.item_name || "",
            po_no: trimmedBody.po_no || "",
            brand: trimmedBody.brand || null,
            model: trimmedBody.model || null,
            supplier: trimmedBody.supplier || "",
            qty: 1,
            date: trimmedBody.date || "",
            invoice_no: trimmedBody.invoice_no || "",
            unit_price: trimmedBody.unit_price
              ? parseFloat(trimmedBody.unit_price)
              : null,
            inv_total: trimmedBody.inv_total
              ? parseFloat(trimmedBody.inv_total)
              : null,
            manufacturer: trimmedBody.manufacturer || null,
            type: trimmedBody.type || null,
            source: trimmedBody.source || null,
            receive_type: trimmedBody.receive_type || null,
            remarks: trimmedBody.remarks || null,
            grn_date: trimmedBody.grn_date || "",
            grn_no: trimmedBody.grn_no || "",
            warranty_expiry: trimmedBody.warranty_expiry || null,
            service_start: trimmedBody.service_start || null,
            service_end: trimmedBody.service_end || null,
            salvage_value: trimmedBody.salvage_value
              ? parseFloat(trimmedBody.salvage_value)
              : null,
            replicate: 1,

            // Asset allocation fields
            center: asset.center || null,
            location: asset.location || null,
            department: asset.department || null,
            employee: asset.employee || null,
            serial_no: asset.serialNo || null,
            book_no_local_id: asset.bookNoLocalId || null,
            barcode_no: asset.barcodeNo || null,

            // Image data - file paths
            ...imageData,
          };

          itemsToInsert.push(itemGRNData);
        }
      } else {
        // Single record (non-replicate mode)
        const firstAsset =
          assetAllocations.length > 0 ? assetAllocations[0] : {};

        // Generate ItemSerial for single item
        const singleItemSerial = await generateItemSerial(
          trimmedBody.grn_date,
          trimmedBody.grn_no,
          false // Not replicate
        );
        console.log(
          `Generated custom ItemSerial for single item: ${singleItemSerial}`
        );

        const itemGRNData = {
          // CUSTOM ItemSerial
          item_serial: singleItemSerial,

          // Main form fields
          middle_category: trimmedBody.middle_category || "",
          sub_category: trimmedBody.sub_category || "",
          item_name: trimmedBody.item_name || "",
          po_no: trimmedBody.po_no || "",
          brand: trimmedBody.brand || null,
          model: trimmedBody.model || null,
          supplier: trimmedBody.supplier || "",
          qty: quantity,
          date: trimmedBody.date || "",
          invoice_no: trimmedBody.invoice_no || "",
          unit_price: trimmedBody.unit_price
            ? parseFloat(trimmedBody.unit_price)
            : null,
          inv_total: trimmedBody.inv_total
            ? parseFloat(trimmedBody.inv_total)
            : null,
          manufacturer: trimmedBody.manufacturer || null,
          type: trimmedBody.type || null,
          source: trimmedBody.source || null,
          receive_type: trimmedBody.receive_type || null,
          remarks: trimmedBody.remarks || null,
          grn_date: trimmedBody.grn_date || "",
          grn_no: trimmedBody.grn_no || "",
          warranty_expiry: trimmedBody.warranty_expiry || null,
          service_start: trimmedBody.service_start || null,
          service_end: trimmedBody.service_end || null,
          salvage_value: trimmedBody.salvage_value
            ? parseFloat(trimmedBody.salvage_value)
            : null,
          replicate: 0,

          // Asset allocation fields
          center: firstAsset.center || null,
          location: firstAsset.location || null,
          department: firstAsset.department || null,
          employee: firstAsset.employee || null,
          serial_no: firstAsset.serialNo || null,
          book_no_local_id: firstAsset.bookNoLocalId || null,
          barcode_no: firstAsset.barcodeNo || null,

          // Image data - file paths
          ...imageData,
        };

        itemsToInsert.push(itemGRNData);
      }

      // Validate required fields
      const requiredFields = [
        "sub_category",
        "item_name",
        "po_no",
        "invoice_no",
        "grn_date",
        "grn_no",
      ];

      for (const itemData of itemsToInsert) {
        const validationErrors = [];
        requiredFields.forEach((field) => {
          if (!itemData[field] || itemData[field].toString().trim() === "") {
            validationErrors.push(`${field.replace("_", " ")} is required`);
          }
        });

        if (validationErrors.length > 0) {
          console.log("Validation errors:", validationErrors);
          await connection.rollback();
          return res.status(400).json({
            success: false,
            message: "Validation failed",
            errors: validationErrors,
          });
        }
      }

      // Create all items
      console.log(`Inserting ${itemsToInsert.length} items into database`);
      for (const itemData of itemsToInsert) {
        console.log("Inserting item with data:", {
          item_serial: itemData.item_serial,
          item_name: itemData.item_name,
          grn_no: itemData.grn_no,
          serial_no: itemData.serial_no,
          has_images: !!(
            itemData.Item1Pic ||
            itemData.Item2Pic ||
            itemData.Item3Pic ||
            itemData.Item4Pic
          ),
        });

        const itemId = await ItemGRNModel.create(itemData);
        console.log("✓ Item created with ID:", itemId);
        insertedIds.push(itemId);
      }

      await connection.commit();

      const imagesProcessed = Object.values(imageData).filter(
        (img) => img !== null
      ).length;
      console.log(
        `✓ Transaction committed. Created ${insertedIds.length} items with ${imagesProcessed} image paths`
      );

      res.status(201).json({
        success: true,
        message: isExistingGRN
          ? "Item(s) added to existing GRN successfully"
          : "New Item GRN created successfully",
        data: {
          ids: insertedIds,
          item_serial: customItemSerial || insertedIds[0], // Return the custom ItemSerial
          grn_no: trimmedBody.grn_no,
          count: insertedIds.length,
          is_existing: isExistingGRN,
          is_replicate: isReplicate,
          images_processed: imagesProcessed,
        },
      });
    } catch (error) {
      await connection.rollback();
      console.error("Error creating Item GRN:", error);
      console.error("Error stack:", error.stack);

      res.status(500).json({
        success: false,
        message: "Failed to create Item GRN",
        error: error.message,
      });
    } finally {
      connection.release();
    }
  }

  // Add this method to itemGRNController.js for testing
  static async testSimpleQuery(req, res) {
    try {
      console.log("=== TEST SIMPLE QUERY ===");

      // Test a simple query without pagination
      const [simpleResult] = await pool.execute(
        "SELECT ItemSerial, ItemName, GrnNo FROM item_grn ORDER BY CreatedAt DESC LIMIT 5"
      );

      // Test with COUNT
      const [countResult] = await pool.execute(
        "SELECT COUNT(*) as total FROM item_grn"
      );

      // Test with string interpolation
      const limit = 3;
      const offset = 0;
      const [interpolatedResult] = await pool.execute(
        `SELECT ItemSerial, ItemName FROM item_grn ORDER BY CreatedAt DESC LIMIT ${limit} OFFSET ${offset}`
      );

      res.json({
        success: true,
        data: {
          simple_query_count: simpleResult.length,
          total_items: countResult[0].total,
          interpolated_query_count: interpolatedResult.length,
          sample_items: simpleResult.map((item) => ({
            ItemSerial: item.ItemSerial,
            ItemName: item.ItemName,
            GrnNo: item.GrnNo,
          })),
        },
      });
    } catch (error) {
      console.error("Test simple query error:", error);
      res.status(500).json({
        success: false,
        message: "Test failed",
        error: error.message,
      });
    }
  }

  // In itemGRNController.js, modify the searchItemGRNs method:
  static async searchItemGRNs(req, res) {
    try {
      console.log("=== SEARCH ITEM GRNS ENDPOINT ===");
      console.log("Query params:", req.query);

      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";

      console.log(
        `Searching: page=${page}, limit=${limit}, search="${search}"`
      );

      // Use the existing findAll method which is working
      const result = await ItemGRNModel.findAll(page, limit, search);

      console.log(
        `Found ${result.data.length} results, total: ${result.pagination.total}`
      );

      res.json({
        success: true,
        ...result,
      });
    } catch (error) {
      console.error("Error searching Item GRNs:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({
        success: false,
        message: "Failed to search Item GRNs",
        error: error.message,
      });
    }
  }

  // Get all Item GRNs with pagination - Updated for single table
  static async getAllItemGRNs(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const search = req.query.search || "";

      const result = await ItemGRNModel.findAll(page, limit, search);

      res.json({
        success: true,
        ...result,
      });
    } catch (error) {
      console.error("Error fetching Item GRNs:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Item GRNs",
        error: error.message,
      });
    }
  }

  // Get Item GRN by ID
  static async getItemGRNById(req, res) {
    try {
      const { id } = req.params;

      // Get main Item GRN data
      const itemGRN = await ItemGRNModel.findById(id);
      if (!itemGRN) {
        return res.status(404).json({
          success: false,
          message: "Item GRN not found",
        });
      }

      // Get all items with same GRN number
      const relatedItems = await ItemGRNModel.findByGrnNo(itemGRN.GrnNo);

      res.json({
        success: true,
        data: {
          ...itemGRN,
          related_items: relatedItems.length,
          // Don't send BLOB data in list view to reduce payload
          has_images:
            itemGRN.Item1Pic ||
            itemGRN.Item2Pic ||
            itemGRN.Item3Pic ||
            itemGRN.Item4Pic,
        },
      });
    } catch (error) {
      console.error("Error fetching Item GRN:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Item GRN",
        error: error.message,
      });
    }
  }

  // Add this simple test method for debugging
  static async testSearch(req, res) {
    try {
      console.log("=== TEST SEARCH ENDPOINT ===");

      // Test 1: Direct query without parameters
      const [testResult1] = await pool.execute(
        "SELECT COUNT(*) as count FROM item_grn"
      );
      console.log("Test 1 - Simple count:", testResult1[0].count);

      // Test 2: Query with LIMIT and OFFSET as numbers
      const [testResult2] = await pool.execute(
        "SELECT ItemSerial FROM item_grn ORDER BY CreatedAt DESC LIMIT 10 OFFSET 0"
      );
      console.log("Test 2 - With LIMIT:", testResult2.length);

      // Test 3: Query with placeholders for LIMIT
      const [testResult3] = await pool.execute(
        "SELECT ItemSerial FROM item_grn ORDER BY CreatedAt DESC LIMIT ? OFFSET ?",
        [10, 0]
      );
      console.log("Test 3 - With placeholders for LIMIT:", testResult3.length);

      res.json({
        success: true,
        data: {
          test1: testResult1[0].count,
          test2: testResult2.length,
          test3: testResult3.length,
        },
      });
    } catch (error) {
      console.error("Test search error:", error);
      res.status(500).json({
        success: false,
        message: "Test failed",
        error: error.message,
      });
    }
  }

  // Get Item GRN by GRN number (returns all items with same GRN)
  static async getItemGRNByGrnNo(req, res) {
    try {
      const { grn_no } = req.params;

      // Get all items with this GRN number with ALL fields
      const [items] = await pool.execute(
        `SELECT * FROM item_grn WHERE GrnNo = ? ORDER BY ItemSerial`,
        [grn_no]
      );

      if (!items || items.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Item GRN not found",
        });
      }

      // Group common data from first item
      const responseData = {
        grn_no: grn_no,
        total_items: items.length,
        items: items.map((item) => ({
          // Complete item data for form population
          id: item.ItemSerial,
          item_serial: item.ItemSerial,
          center_id: item.StationId,
          department_serial: item.DepartmentSerial,
          location: item.X,
          employee_serial: item.EmployeeSerial,
          middle_category_id: item.MiddleCategory,
          sub_category_id: item.SubCategoryId,
          item_name: item.ItemName,
          brand: item.Brand,
          model: item.Model,
          manufacture: item.Manufacture,
          type: item.Type,
          warranty_expire_date: item.WarrantyExpireDate,
          service_agreement_start_date: item.ServiceAgreementStartDate,
          service_agreement_end_date: item.ServiceAgreementEndDate,
          serial_no: item.SerialNo,
          book_no: item.BookNo,
          barcode_no: item.BarcodeNo,
          supplier_serial: item.SupplierSerial,
          po_no: item.PONo,
          purchase_date: item.PurchaseDate,
          invoice_no: item.InvoiceNo,
          unit_price: item.UnitPrice,
          invoice_total: item.InvoiceTotal,
          in_type: item.InType,
          source: item.Source,
          salvage_value: item.SalvageValue,
          remarks: item.Remarks,
          grn_date: item.GRNdate,
          transport_cost: item.TransportCost,
          installation_cost: item.InstallationCost,
          nbt: item.NBT,
          vat: item.VAT,
          other_cost: item.OtherCost,
          purchase_type: item.PurchaseType,
          has_images: !!(
            item.Item1Pic ||
            item.Item2Pic ||
            item.Item3Pic ||
            item.Item4Pic
          ),
        })),
        common_info: {
          // Fields that should be same for all items in this GRN
          brand: items[0].Brand,
          po_no: items[0].PONo,
          invoice_no: items[0].InvoiceNo,
          grn_date: items[0].GRNdate,
          supplier: items[0].Supplier,
          purchase_date: items[0].PurchaseDate,
          unit_price: items[0].UnitPrice,
          invoice_total: items[0].InvoiceTotal,
          manufacture: items[0].Manufacture,
          type: items[0].Type,
          source: items[0].Source,
          in_type: items[0].InType,
          remarks: items[0].Remarks,
          warranty_expire_date: items[0].WarrantyExpireDate,
          service_agreement_start_date: items[0].ServiceAgreementStartDate,
          service_agreement_end_date: items[0].ServiceAgreementEndDate,
          salvage_value: items[0].SalvageValue,
        },
      };

      res.json({
        success: true,
        data: responseData,
      });
    } catch (error) {
      console.error("Error fetching Item GRN:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Item GRN",
        error: error.message,
      });
    }
  }

  // Get image by item ID and image number (1-4)
  static async getItemImage(req, res) {
    try {
      const { id, imageNumber } = req.params;
      const imageNum = parseInt(imageNumber);

      if (imageNum < 1 || imageNum > 4) {
        return res.status(400).json({
          success: false,
          message: "Image number must be between 1 and 4",
        });
      }

      const imageColumn = `Item${imageNum}Pic`;
      const [rows] = await pool.execute(
        `SELECT ${imageColumn} FROM item_grn WHERE ItemSerial = ?`,
        [id]
      );

      if (!rows[0] || !rows[0][imageColumn]) {
        return res.status(404).json({
          success: false,
          message: "Image not found in database",
        });
      }

      const filePath = rows[0][imageColumn];

      // Check if file exists using fileExists helper
      if (!fileExists(filePath)) {
        return res.status(404).json({
          success: false,
          message: "Image file not found on server",
        });
      }

      // Determine content type from file extension
      const path = require("path");
      const extension = path.extname(filePath).toLowerCase();
      let contentType = "image/jpeg";

      switch (extension) {
        case ".jpg":
        case ".jpeg":
          contentType = "image/jpeg";
          break;
        case ".png":
          contentType = "image/png";
          break;
        case ".gif":
          contentType = "image/gif";
          break;
        case ".bmp":
          contentType = "image/bmp";
          break;
        case ".webp":
          contentType = "image/webp";
          break;
      }

      res.set("Content-Type", contentType);
      res.sendFile(path.resolve(filePath));
    } catch (error) {
      console.error("Error fetching item image:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch image",
        error: error.message,
      });
    }
  }

  // Update Item GRN
  static async updateItemGRN(req, res) {
    const connection = await pool.getConnection();

    try {
      await connection.beginTransaction();

      const { id } = req.params;

      console.log("=== UPDATE ITEM GRN REQUEST ===");
      console.log("Update ID:", id);
      console.log("Request body:", req.body);
      console.log("Files received:", req.files ? req.files.length : 0);

      // Create trimmed version of req.body
      const trimmedBody = {};
      Object.keys(req.body).forEach((key) => {
        trimmedBody[key.trim()] = req.body[key];
      });

      // Process asset allocations if exists
      let assetAllocations = [];
      if (trimmedBody.assetAllocations) {
        try {
          assetAllocations = JSON.parse(trimmedBody.assetAllocations);
          console.log("Asset allocations parsed:", assetAllocations.length);
        } catch (error) {
          console.error("Error parsing asset allocations:", error);
        }
      }

      // Check if Item GRN exists
      const existingItemGRN = await ItemGRNModel.findById(id);
      if (!existingItemGRN) {
        await connection.rollback();
        return res.status(404).json({
          success: false,
          message: "Item GRN not found",
        });
      }

      // Check if GRN number is being updated and if it already exists
      if (trimmedBody.grn_no && trimmedBody.grn_no !== existingItemGRN.GrnNo) {
        const grnExists = await ItemGRNModel.checkGRNNoExists(
          trimmedBody.grn_no,
          id
        );
        if (grnExists) {
          await connection.rollback();
          return res.status(400).json({
            success: false,
            message:
              "GRN number already exists. Please use a unique GRN number.",
          });
        }
      }

      // Prepare update data
      const updateData = {
        // Map frontend fields to database columns
        middle_category: trimmedBody.middle_category,
        sub_category: trimmedBody.sub_category,
        item_name: trimmedBody.item_name,
        po_no: trimmedBody.po_no,
        brand: trimmedBody.brand,
        model: trimmedBody.model,
        supplier: trimmedBody.supplier,

        date: trimmedBody.date ? new Date(trimmedBody.date) : null,
        invoice_no: trimmedBody.invoice_no,
        unit_price: trimmedBody.unit_price
          ? parseFloat(trimmedBody.unit_price)
          : null,
        inv_total: trimmedBody.inv_total
          ? parseFloat(trimmedBody.inv_total)
          : null,
        manufacturer: trimmedBody.manufacturer,
        type: trimmedBody.type,
        source: trimmedBody.source,
        receive_type: trimmedBody.receive_type,
        remarks: trimmedBody.remarks,
        grn_date: trimmedBody.grn_date ? new Date(trimmedBody.grn_date) : null,
        grn_no: trimmedBody.grn_no,
        warranty_expiry: trimmedBody.warranty_expiry
          ? new Date(trimmedBody.warranty_expiry)
          : null,
        service_start: trimmedBody.service_start
          ? new Date(trimmedBody.service_start)
          : null,
        service_end: trimmedBody.service_end
          ? new Date(trimmedBody.service_end)
          : null,
        salvage_value: trimmedBody.salvage_value
          ? parseFloat(trimmedBody.salvage_value)
          : null,
        replicate: trimmedBody.replicate === "true" ? 1 : 0,
      };

      // Process images if any
      if (req.files && req.files.length > 0) {
        console.log(`Processing ${req.files.length} images for update`);

        for (let i = 0; i < Math.min(req.files.length, 4); i++) {
          const file = req.files[i];
          const imageKey = `Item${i + 1}Pic`;

          try {
            console.log(`Processing image ${i + 1}: ${file.originalname}`);
            console.log(`File saved at: ${file.path}`);

            // Store file path
            updateData[imageKey] = file.path;
            console.log(`✓ Stored ${imageKey} path: ${file.path}`);
          } catch (error) {
            console.error(`Error getting file path for image ${i + 1}:`, error);
          }
        }
      }

      // Update Item GRN
      const updatedRows = await ItemGRNModel.update(id, updateData);
      if (updatedRows === 0) {
        await connection.rollback();
        return res.status(400).json({
          success: false,
          message: "No changes made",
        });
      }

      await connection.commit();

      res.json({
        success: true,
        message: "Item GRN updated successfully",
        data: {
          id: id,
          updated_fields: Object.keys(updateData).filter(
            (key) => updateData[key] !== undefined
          ),
        },
      });
    } catch (error) {
      await connection.rollback();
      console.error("Error updating Item GRN:", error);
      console.error("Error stack:", error.stack);

      if (error.code === "ER_DUP_ENTRY") {
        return res.status(400).json({
          success: false,
          message: "GRN number already exists. Please use a unique GRN number.",
        });
      }

      res.status(500).json({
        success: false,
        message: "Failed to update Item GRN",
        error: error.message,
      });
    } finally {
      connection.release();
    }
  }

  // Update ALL items with the same GRN number
  static async updateAllByGrnNo(req, res) {
    const connection = await pool.getConnection();

    try {
      await connection.beginTransaction();

      const { grn_no } = req.params;

      console.log("=== UPDATE ALL BY GRN NO REQUEST ===");
      console.log("GRN No:", grn_no);
      console.log("Request body keys:", Object.keys(req.body));
      console.log("Files received:", req.files ? req.files.length : 0);

      // Create trimmed version of req.body
      const trimmedBody = {};
      Object.keys(req.body).forEach((key) => {
        trimmedBody[key.trim()] = req.body[key];
      });

      // Process asset allocations if exists
      let assetAllocations = [];
      if (trimmedBody.assetAllocations) {
        try {
          assetAllocations = JSON.parse(trimmedBody.assetAllocations);
          console.log("Asset allocations parsed:", assetAllocations.length);
        } catch (error) {
          console.error("Error parsing asset allocations:", error);
        }
      }

      // Check if any items exist with this GRN number
      const existingItems = await ItemGRNModel.findByGrnNo(grn_no);
      if (!existingItems || existingItems.length === 0) {
        await connection.rollback();
        return res.status(404).json({
          success: false,
          message: "No items found with this GRN number",
        });
      }

      console.log(
        `Found ${existingItems.length} existing items with GRN ${grn_no}`
      );

      // Determine if we're in replicate mode
      const isReplicate =
        trimmedBody.replicate === "true" ||
        trimmedBody.replicate === true ||
        (assetAllocations.length > 1 && parseInt(trimmedBody.qty) > 1);

      console.log("Is replicate mode:", isReplicate);

      // Prepare update data for common fields
      const commonUpdateData = {
        // Map frontend fields to database columns
        middle_category: trimmedBody.middle_category,
        sub_category: trimmedBody.sub_category,
        item_name: trimmedBody.item_name,
        po_no: trimmedBody.po_no,
        brand: trimmedBody.brand,
        model: trimmedBody.model,
        supplier: trimmedBody.supplier,
        date: trimmedBody.date ? new Date(trimmedBody.date) : null,
        invoice_no: trimmedBody.invoice_no,
        unit_price: trimmedBody.unit_price
          ? parseFloat(trimmedBody.unit_price)
          : null,
        inv_total: trimmedBody.inv_total
          ? parseFloat(trimmedBody.inv_total)
          : null,
        manufacturer: trimmedBody.manufacturer,
        type: trimmedBody.type,
        source: trimmedBody.source,
        receive_type: trimmedBody.receive_type,
        remarks: trimmedBody.remarks,
        grn_date: trimmedBody.grn_date ? new Date(trimmedBody.grn_date) : null,
        grn_no: grn_no, // Keep the same GRN number
        warranty_expiry: trimmedBody.warranty_expiry
          ? new Date(trimmedBody.warranty_expiry)
          : null,
        service_start: trimmedBody.service_start
          ? new Date(trimmedBody.service_start)
          : null,
        service_end: trimmedBody.service_end
          ? new Date(trimmedBody.service_end)
          : null,
        salvage_value: trimmedBody.salvage_value
          ? parseFloat(trimmedBody.salvage_value)
          : null,
        replicate: isReplicate ? 1 : 0,
      };

      // Process images if any
      if (req.files && req.files.length > 0) {
        console.log(`Processing ${req.files.length} images for update`);

        for (let i = 0; i < Math.min(req.files.length, 4); i++) {
          const file = req.files[i];
          const imageKey = `Item${i + 1}Pic`;

          try {
            console.log(`Processing image ${i + 1}: ${file.originalname}`);
            console.log(`File saved at: ${file.path}`);

            // Store file path
            commonUpdateData[imageKey] = file.path;
            console.log(`✓ Stored ${imageKey} path: ${file.path}`);
          } catch (error) {
            console.error(`Error getting file path for image ${i + 1}:`, error);
          }
        }
      }

      let updatedCount = 0;
      const updatedItemSerials = [];

      // Update each item individually
      for (let i = 0; i < existingItems.length; i++) {
        const item = existingItems[i];
        const itemUpdateData = { ...commonUpdateData };

        // For each item, add its specific asset allocation data
        if (i < assetAllocations.length) {
          const asset = assetAllocations[i];
          itemUpdateData.center = asset.center || null;
          itemUpdateData.location = asset.location || null;
          itemUpdateData.department = asset.department || null;
          itemUpdateData.employee = asset.employee || null;
          itemUpdateData.serial_no = asset.serialNo || null;
          itemUpdateData.book_no_local_id = asset.bookNoLocalId || null;
          itemUpdateData.barcode_no = asset.barcodeNo || null;

          console.log(`Updating item ${i + 1} with asset data:`, {
            serialNo: asset.serialNo,
            department: asset.department,
            center: asset.center,
          });
        } else {
          console.log(
            `No asset allocation data for item ${i + 1}, using existing data`
          );
        }

        console.log(`Updating item ${item.ItemSerial} with data:`, {
          item_name: itemUpdateData.item_name,
          grn_no: itemUpdateData.grn_no,
          serial_no: itemUpdateData.serial_no,
        });

        // Update the item
        const updatedRows = await ItemGRNModel.update(
          item.ItemSerial,
          itemUpdateData
        );

        if (updatedRows > 0) {
          updatedCount++;
          updatedItemSerials.push(item.ItemSerial);
          console.log(`✓ Updated item ${item.ItemSerial}`);
        } else {
          console.log(`No changes for item ${item.ItemSerial}`);
        }
      }

      // Handle quantity changes if needed
      const newQuantity = parseInt(trimmedBody.qty) || existingItems.length;
      console.log(
        `New quantity: ${newQuantity}, Existing items: ${existingItems.length}`
      );

      if (newQuantity > existingItems.length && isReplicate) {
        // Need to add more items in replicate mode
        const itemsToAdd = newQuantity - existingItems.length;
        console.log(`Adding ${itemsToAdd} new items in replicate mode`);

        // Use the first asset allocation as template for new items
        const templateAsset =
          assetAllocations.length > 0
            ? assetAllocations[0]
            : existingItems[0]
            ? {
                center: existingItems[0].StationId,
                department: existingItems[0].DepartmentSerial,
                serialNo: existingItems[0].SerialNo,
              }
            : {};

        for (let i = 0; i < itemsToAdd; i++) {
          const newIndex = existingItems.length + i + 1;

          // Generate unique ItemSerial for new item
          const newItemSerial = await generateItemSerial(
            trimmedBody.grn_date,
            grn_no,
            true, // isReplicate
            newIndex - 1 // index
          );

          const newItemData = {
            ...commonUpdateData,
            center: templateAsset.center || null,
            location: templateAsset.location || null,
            department: templateAsset.department || null,
            employee: templateAsset.employee || null,
            serial_no: templateAsset.serialNo
              ? `${
                  templateAsset.serialNo.split("-")[0] || templateAsset.serialNo
                }-${newIndex}`
              : null,
            book_no_local_id: templateAsset.bookNoLocalId
              ? `${
                  templateAsset.bookNoLocalId.split("-")[0] ||
                  templateAsset.bookNoLocalId
                }-${newIndex}`
              : null,
            barcode_no: templateAsset.barcodeNo
              ? `${
                  templateAsset.barcodeNo.split("-")[0] ||
                  templateAsset.barcodeNo
                }-${newIndex}`
              : null,
            qty: 1,
            grn_no: grn_no,
            item_serial: newItemSerial,
            replicate: 1,
          };

          console.log(`Creating new item ${i + 1}:`, {
            item_serial: newItemData.item_serial,
            serial_no: newItemData.serial_no,
          });

          const newItemId = await ItemGRNModel.create(newItemData);
          updatedItemSerials.push(newItemId);
          updatedCount++;
          console.log(`✓ Created new item ${newItemId}`);
        }
      } else if (newQuantity < existingItems.length && isReplicate) {
        // Need to remove items in replicate mode
        const itemsToRemove = existingItems.length - newQuantity;
        console.log(`Removing ${itemsToRemove} items in replicate mode`);

        // Remove from the end (keep the first ones)
        for (let i = 0; i < itemsToRemove; i++) {
          const itemIndex = existingItems.length - 1 - i;
          const itemToRemove = existingItems[itemIndex];

          console.log(`Deleting item ${itemToRemove.ItemSerial}`);
          await ItemGRNModel.delete(itemToRemove.ItemSerial);
          console.log(`✓ Deleted item ${itemToRemove.ItemSerial}`);
        }
      }

      await connection.commit();

      console.log(`Update completed. Updated ${updatedCount} items total.`);

      res.json({
        success: true,
        message: "All items updated successfully",
        data: {
          updated_count: updatedCount,
          grn_no: grn_no,
          updated_item_serials: updatedItemSerials,
          original_count: existingItems.length,
          new_count: newQuantity,
          is_replicate: isReplicate,
        },
      });
    } catch (error) {
      await connection.rollback();
      console.error("Error updating all items by GRN:", error);
      console.error("Error stack:", error.stack);

      if (error.code === "ER_DUP_ENTRY") {
        return res.status(400).json({
          success: false,
          message: "GRN number already exists. Please use a unique GRN number.",
        });
      }

      res.status(500).json({
        success: false,
        message: "Failed to update items",
        error: error.message,
      });
    } finally {
      connection.release();
    }
  }

  // Delete Item GRN
  static async deleteItemGRN(req, res) {
    const connection = await pool.getConnection();

    try {
      await connection.beginTransaction();

      const { id } = req.params;

      // Check if Item GRN exists
      const existingItemGRN = await ItemGRNModel.findById(id);
      if (!existingItemGRN) {
        await connection.rollback();
        return res.status(404).json({
          success: false,
          message: "Item GRN not found",
        });
      }

      // Delete Item GRN
      const deletedRows = await ItemGRNModel.delete(id);

      if (deletedRows === 0) {
        await connection.rollback();
        return res.status(400).json({
          success: false,
          message: "Failed to delete Item GRN",
        });
      }

      await connection.commit();

      res.json({
        success: true,
        message: "Item GRN deleted successfully",
      });
    } catch (error) {
      await connection.rollback();
      console.error("Error deleting Item GRN:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete Item GRN",
        error: error.message,
      });
    } finally {
      connection.release();
    }
  }

  // Get Item GRN statistics
  static async getStats(req, res) {
    try {
      const stats = await ItemGRNModel.getStats();
      res.json({
        success: true,
        data: stats,
      });
    } catch (error) {
      console.error("Error fetching Item GRN stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Item GRN statistics",
        error: error.message,
      });
    }
  }

  // Generate new GRN number
  static async generateGRNNo(req, res) {
    try {
      // Get the last GRN number from database
      const [result] = await pool.execute(
        "SELECT GrnNo FROM item_grn ORDER BY CreatedAt DESC LIMIT 1"
      );

      let nextNumber = 1;

      if (result.length > 0 && result[0].GrnNo) {
        const lastGrnNo = result[0].GrnNo;
        console.log("Last GRN number found:", lastGrnNo);

        // Extract the numeric part from GRN000001 format
        const match = lastGrnNo.match(/GRN(\d+)/i);
        if (match && match[1]) {
          nextNumber = parseInt(match[1]) + 1;
        } else {
          // Try to find any GRN number pattern
          const anyMatch = lastGrnNo.match(/\d+/);
          if (anyMatch) {
            nextNumber = parseInt(anyMatch[0]) + 1;
          }
        }

        // Ensure we don't generate a duplicate
        // Check if this GRN already exists
        const [checkResult] = await pool.execute(
          "SELECT GrnNo FROM item_grn WHERE GrnNo = ?",
          [`GRN${String(nextNumber).padStart(6, "0")}`]
        );

        while (checkResult.length > 0) {
          nextNumber++;
          const [newCheck] = await pool.execute(
            "SELECT GrnNo FROM item_grn WHERE GrnNo = ?",
            [`GRN${String(nextNumber).padStart(6, "0")}`]
          );
          if (newCheck.length === 0) break;
        }
      }

      // Format as GRN000001
      const grnNo = `GRN${String(nextNumber).padStart(6, "0")}`;
      console.log("Generated new GRN number:", grnNo);

      res.json({
        success: true,
        data: {
          grn_no: grnNo,
        },
      });
    } catch (error) {
      console.error("Error generating GRN number:", error);

      // If table doesn't exist or is empty, start from GRN000001
      res.json({
        success: true,
        data: {
          grn_no: "GRN000001",
        },
      });
    }
  }

  // Get existing GRN numbers
  static async getExistingGrnNumbers(req, res) {
    try {
      const [rows] = await pool.execute(
        "SELECT DISTINCT GrnNo FROM item_grn ORDER BY GrnNo DESC"
      );

      res.json({
        success: true,
        data: rows,
      });
    } catch (error) {
      console.error("Error fetching GRN numbers:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch GRN numbers",
        error: error.message,
      });
    }
  }

  // Get all Item GRNs with ALL fields
  static async getAllItemGRNsComplete(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const search = req.query.search || "";

      const offset = (page - 1) * limit;

      // Build the query to get ALL fields
      let query = `
      SELECT * FROM item_grn WHERE 1=1
    `;

      let countQuery = `SELECT COUNT(*) as total FROM item_grn WHERE 1=1`;

      const queryParams = [];
      const countParams = [];

      if (search && search.trim() !== "") {
        const searchTerm = `%${search.trim()}%`;
        query += ` AND (
        ItemName LIKE ? OR 
        InvoiceNo LIKE ? OR 
        GrnNo LIKE ? OR 
        SerialNo LIKE ? OR
        BarcodeNo LIKE ? OR
        ItemSerial LIKE ? OR
        PONo LIKE ? OR
        Manufacture LIKE ?
      )`;
        countQuery += ` AND (
        ItemName LIKE ? OR 
        InvoiceNo LIKE ? OR 
        GrnNo LIKE ? OR 
        SerialNo LIKE ? OR
        BarcodeNo LIKE ? OR
        ItemSerial LIKE ? OR
        PONo LIKE ? OR
        Manufacture LIKE ?
      )`;

        for (let i = 0; i < 8; i++) {
          queryParams.push(searchTerm);
          countParams.push(searchTerm);
        }
      }

      // Add ordering and pagination
      query += ` ORDER BY ItemSerial DESC LIMIT ${limit} OFFSET ${offset}`;

      console.log("=== GET ALL COMPLETE QUERY ===");
      console.log("Query:", query);
      console.log("Params:", queryParams);

      // Execute queries
      const [rows] =
        queryParams.length > 0
          ? await pool.execute(query, queryParams)
          : await pool.execute(query);

      const [countResult] =
        countParams.length > 0
          ? await pool.execute(countQuery, countParams)
          : await pool.execute(countQuery);

      const total = countResult[0].total;

      res.json({
        success: true,
        data: rows,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
        },
      });
    } catch (error) {
      console.error("Error fetching complete Item GRNs:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Item GRNs",
        error: error.message,
      });
    }
  }

  // Get complete Item GRN by ID with images
  static async getItemGRNCompleteById(req, res) {
    try {
      const { id } = req.params;

      // Get complete Item GRN data including images
      const itemGRN = await ItemGRNModel.getCompleteItemById(id);
      if (!itemGRN) {
        return res.status(404).json({
          success: false,
          message: "Item GRN not found",
        });
      }

      // Get all items with same GRN number
      const relatedItems = await ItemGRNModel.findByGrnNo(itemGRN.GrnNo);

      // Don't send base64 images in the response to reduce payload
      // Instead, indicate which images are available
      const responseData = {
        ...itemGRN,
        has_images: {
          Item1Pic: !!itemGRN.Item1Pic,
          Item2Pic: !!itemGRN.Item2Pic,
          Item3Pic: !!itemGRN.Item3Pic,
          Item4Pic: !!itemGRN.Item4Pic,
        },
        related_items: relatedItems.length,
        // Remove actual base64 data from response
        Item1Pic: undefined,
        Item2Pic: undefined,
        Item3Pic: undefined,
        Item4Pic: undefined,
      };

      res.json({
        success: true,
        data: responseData,
      });
    } catch (error) {
      console.error("Error fetching Item GRN:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Item GRN",
        error: error.message,
      });
    }
  }

  // Helper function to get numeric department ID
  static async getNumericDepartmentId(departmentStringId) {
    try {
      const [rows] = await pool.execute(
        "SELECT numeric_id FROM departments WHERE department_id = ?",
        [departmentStringId]
      );

      if (rows.length > 0 && rows[0].numeric_id) {
        return rows[0].numeric_id;
      }

      // If no numeric_id found, try to extract from string
      const match = departmentStringId.match(/\d+/);
      return match ? parseInt(match[0]) : null;
    } catch (error) {
      console.error("Error getting numeric department ID:", error);
      return null;
    }
  }

  // Serve image file from file path
  static async serveImageFile(req, res) {
    try {
      const { id, imageNumber } = req.params;
      const imageNum = parseInt(imageNumber);

      if (imageNum < 1 || imageNum > 4) {
        return res.status(400).json({
          success: false,
          message: "Image number must be between 1 and 4",
        });
      }

      const imageColumn = `Item${imageNum}Pic`;
      const [rows] = await pool.execute(
        `SELECT ${imageColumn} FROM item_grn WHERE ItemSerial = ?`,
        [id]
      );

      if (!rows[0] || !rows[0][imageColumn]) {
        return res.status(404).json({
          success: false,
          message: "Image not found in database",
        });
      }

      const filePath = rows[0][imageColumn];
      console.log(`Attempting to serve image from: ${filePath}`);

      // Check if file exists
      const fs = require("fs");
      const path = require("path");

      // Resolve absolute path
      const absolutePath = path.resolve(filePath);

      if (!fs.existsSync(absolutePath)) {
        console.error(`Image file not found: ${absolutePath}`);

        // Try relative path from project root
        const relativePath = path.join(__dirname, "..", "..", filePath);
        console.log(`Trying relative path: ${relativePath}`);

        if (fs.existsSync(relativePath)) {
          return res.sendFile(relativePath);
        }

        return res.status(404).json({
          success: false,
          message: "Image file not found on server",
          path: filePath,
        });
      }

      // Determine content type from file extension
      const extension = path.extname(filePath).toLowerCase();
      let contentType = "image/jpeg";

      switch (extension) {
        case ".jpg":
        case ".jpeg":
          contentType = "image/jpeg";
          break;
        case ".png":
          contentType = "image/png";
          break;
        case ".gif":
          contentType = "image/gif";
          break;
        case ".bmp":
          contentType = "image/bmp";
          break;
        case ".webp":
          contentType = "image/webp";
          break;
        case ".pdf":
          contentType = "application/pdf";
          break;
      }

      res.set("Content-Type", contentType);
      res.sendFile(absolutePath);
    } catch (error) {
      console.error("Error serving image file:", error);
      res.status(500).json({
        success: false,
        message: "Failed to serve image",
        error: error.message,
      });
    }
  }

  // Check if item has images
  static async checkItemHasImages(req, res) {
    try {
      const { id } = req.params;

      const [rows] = await pool.execute(
        `SELECT 
        Item1Pic,
        Item2Pic,
        Item3Pic,
        Item4Pic
      FROM item_grn WHERE ItemSerial = ?`,
        [id]
      );

      if (!rows[0]) {
        return res.status(404).json({
          success: false,
          message: "Item not found",
        });
      }

      const hasImages = {
        Item1Pic: !!rows[0].Item1Pic,
        Item2Pic: !!rows[0].Item2Pic,
        Item3Pic: !!rows[0].Item3Pic,
        Item4Pic: !!rows[0].Item4Pic,
      };

      res.json({
        success: true,
        data: {
          has_images: hasImages,
          count: Object.values(hasImages).filter(Boolean).length,
        },
      });
    } catch (error) {
      console.error("Error checking item images:", error);
      res.status(500).json({
        success: false,
        message: "Failed to check item images",
        error: error.message,
      });
    }
  }
}

module.exports = ItemGRNController;
