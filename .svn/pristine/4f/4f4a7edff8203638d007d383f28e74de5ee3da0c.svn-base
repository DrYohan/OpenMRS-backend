const path = require("path");
const fs = require("fs").promises;
const fsSync = require("fs");
const pool = require("../config/database"); // ADD THIS LINE

// Format currency
const formatCurrency = (amount) => {
  return new Intl.NumberFormat("en-IN", {
    style: "currency",
    currency: "INR",
    minimumFractionDigits: 2,
  }).format(amount || 0);
};

// Function to get file path
const getFilePath = (file) => {
  return file ? file.path : null;
};

// Function to check if file exists
const fileExists = (filePath) => {
  try {
    return fsSync.existsSync(filePath);
  } catch (error) {
    console.error("Error checking if file exists:", error);
    return false;
  }
};

// Format date
const formatDate = (dateString) => {
  if (!dateString) return "";
  const date = new Date(dateString);
  return date.toLocaleDateString("en-IN");
};

// Generate GRN number
const generateGRNNumber = () => {
  const prefix = "GRN";
  const year = new Date().getFullYear();
  const month = String(new Date().getMonth() + 1).padStart(2, "0");
  const random = Math.floor(Math.random() * 10000)
    .toString()
    .padStart(4, "0");
  return `${prefix}${year}${month}${random}`;
};

// Validate GRN data
const validateGRNData = (data) => {
  const errors = [];

  // Required fields
  const requiredFields = [
    "middle_category",
    "sub_category",
    "item_name",
    "po_no",
    "supplier",
    "qty",
    "date",
    "invoice_no",
    "grn_date",
    "grn_no",
  ];

  requiredFields.forEach((field) => {
    if (!data[field] || data[field].toString().trim() === "") {
      errors.push(`${field.replace("_", " ")} is required`);
    }
  });

  // Numeric validation
  if (data.qty && isNaN(parseInt(data.qty))) {
    errors.push("Quantity must be a number");
  }

  if (data.unit_price && isNaN(parseFloat(data.unit_price))) {
    errors.push("Unit price must be a number");
  }

  if (data.inv_total && isNaN(parseFloat(data.inv_total))) {
    errors.push("Invoice total must be a number");
  }

  if (data.salvage_value && isNaN(parseFloat(data.salvage_value))) {
    errors.push("Salvage value must be a number");
  }

  return errors;
};

// Delete file from filesystem
const deleteFile = async (filePath) => {
  try {
    if (fileExists(filePath)) {
      await fs.unlink(filePath);
      console.log("âœ“ File deleted successfully:", filePath);
      return true;
    }
    console.log("File does not exist:", filePath);
    return false;
  } catch (error) {
    console.error("Error deleting file:", error);
    return false;
  }
};

// Calculate total value
const calculateTotalValue = (rows) => {
  return rows.reduce((total, row) => {
    return total + (parseFloat(row.inv_total) || 0);
  }, 0);
};

// Function to convert image to base64
const processImageToBase64 = async (filePath) => {
  try {
    console.log("Processing image from path:", filePath);

    // Check if file exists
    if (!fileExists(filePath)) {
      console.error("File does not exist:", filePath);
      throw new Error(`File not found: ${filePath}`);
    }

    // Read file as buffer
    const data = await fs.readFile(filePath);

    // Get file extension and determine MIME type
    const extension = path.extname(filePath).toLowerCase();
    let mimeType;

    switch (extension) {
      case ".jpg":
      case ".jpeg":
        mimeType = "image/jpeg";
        break;
      case ".png":
        mimeType = "image/png";
        break;
      case ".gif":
        mimeType = "image/gif";
        break;
      case ".bmp":
        mimeType = "image/bmp";
        break;
      case ".webp":
        mimeType = "image/webp";
        break;
      default:
        mimeType = "image/jpeg";
    }

    // Convert to base64
    const base64Image = data.toString("base64");

    // Return data URL
    const result = `data:${mimeType};base64,${base64Image}`;
    console.log(`Image processed successfully. Size: ${result.length} chars`);
    return result;
  } catch (error) {
    console.error("Error processing image to base64:", error);
    throw error;
  }
};

// Helper function to get MIME type from file extension
const getMimeType = (filePath) => {
  const extension = filePath.split(".").pop().toLowerCase();
  const mimeTypes = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    gif: "image/gif",
    bmp: "image/bmp",
    webp: "image/webp",
    svg: "image/svg+xml",
  };
  return mimeTypes[extension] || "image/jpeg";
};

// Generate unique ItemSerial: YYYYMMDD + 3-digit sequence + suffix for replicate items
const generateItemSerial = async (
  grnDate,
  grnNo,
  isReplicate = false,
  replicateIndex = 0
) => {
  try {
    // Format date as YYYYMMDD
    const date = new Date(grnDate);
    const datePart = date.toISOString().slice(0, 10).replace(/-/g, ""); // YYYYMMDD

    // Get count of items with same date to generate sequence
    const [rows] = await pool.execute(
      "SELECT COUNT(*) as count FROM item_grn WHERE DATE(GRNdate) = DATE(?)",
      [grnDate]
    );

    const baseCount = rows[0].count + 1;
    const sequence = baseCount.toString().padStart(3, "0");

    // For replicate items, add a suffix
    if (isReplicate && replicateIndex > 0) {
      const suffix = String(replicateIndex).padStart(2, "0"); // -01, -02, etc.
      const itemSerial = `${datePart}${sequence}-${suffix}`;
      console.log(
        `Generated ItemSerial for replicate item ${replicateIndex}: ${itemSerial} for date: ${grnDate}`
      );
      return itemSerial;
    } else {
      // For single items or first replicate item
      const itemSerial = `${datePart}${sequence}`;
      console.log(`Generated ItemSerial: ${itemSerial} for date: ${grnDate}`);
      return itemSerial;
    }
  } catch (error) {
    console.error("Error generating ItemSerial:", error);

    // Fallback: Use current date if there's an error
    const datePart = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    const randomSeq = Math.floor(Math.random() * 1000)
      .toString()
      .padStart(3, "0");

    // Add suffix for replicate items
    if (isReplicate && replicateIndex > 0) {
      const suffix = String(replicateIndex).padStart(2, "0");
      return `${datePart}${randomSeq}-${suffix}`;
    }

    return `${datePart}${randomSeq}`;
  }
};

module.exports = {
  formatCurrency,
  formatDate,
  generateGRNNumber,
  validateGRNData,
  deleteFile,
  calculateTotalValue,
  getFilePath,
  fileExists,
  processImageToBase64,
  getMimeType,
  generateItemSerial,
};
